// Gui Script
// ================================ OPTIONS ===============================================
// ============================= EDIT FROM HERE ===========================================

// Setup the default Language (only affects the provided GUIs) 
// Unhandled events can directly be changed in the function Unhandled()

// Currently supported languages:
// eLangEN (English)
// eLangDE (German)
// eLangES (Spanish)
// eLangFR (French)
// eLangIT (Italian)
// eLangPT (Portuguese)
// eLangNl (Dutch)

int lang = eLangEN;           

int
actionLabelColorNormal          = 52959,  // colour used in action bar
actionLabelColorHighlighted     = 24188,  // highlighted colour used in action bar
invUparrowONsprite              = 55,     // sprite slot of the upper inv arrow / normal
invUparrowOFFsprite             = 52,     // sprite slot of the upper inv arrow / disabled
invUparrowHIsprite              = 57,     // sprite slot of the upper inv arrow / highlighted
invDownarrowONsprite            = 56,     //  "   "      "      lower   "   "       
invDownarrowOFFsprite           = 53,     //  "   "      "      lower   "   "
invDownarrowHIsprite            = 58,     //  "   "      "      lower   "   "
walkOffScreenOffset             = 30;     // offset used by WalkOffScreen and exit extensions

bool approachCharInteract       = true;   // walk to character before starting interaction
bool NPCfacingPlayer            = false;  // Non playable characters are facing 
                                          //   the player before talk-to and give-to
                                          //   turned off: right-click on inv items is use
bool objHotTalk                 = false;  // Talk to Objects and Hotspots
bool classicInvHandling         = true;   // turned on: right-click on inv items is lookat, left-click is use
                                          //   all other extensions will be ignored
bool classicGui                 = false;  // action bar is fixed like in classic SCUMM games among other things

bool disableDoubleclick         = false;  // disable doubleclick entirely, voids all doubleclick options
bool exitDoorDoubleclick        = true;   // doubleclick on open doors changes room instantly
bool exitExtensionDoubleclick   = true;   // doubleclick on anything with an exit extension
bool runOnDoubleClick           = true;   // Character speed is doubled on doubleclick
int runCursorDistance           = 10;     // Distance between mouse cursor and player until running begins
int runSpeedupRate              = 2;      // multiplied to the player movement speed, while running
                                          // 1 = no speedup at all, 2 = double speed and so on
               
// ============================= EDIT UNTIL HERE ===========================================



// ========================== internal variables (not to edit) =============================
int global_action;        // containing the current clicked action
int default_action;       // default action (most likely walk-to)
int alternative_action;   // right-click action
int used_action;          // used_action = global_action, if not cancelled
int AGSCursorMode;        // used mouse cursor mode

String location_ex;       // hovered  location name including extension
String location;          // hovered  location name excluding extension
String location_clicked;  // clicked location name including extension
String inv_ex_location;   // inventory name including extension
String inv_location;      // inventory name location excluding extension

String temp_location;     // needed to compare location & clicked location

int location_type;        // the result of GetLocationType
int location_id;          // on_mouse_click -> location id

int player_walk_x_speed;  // Initial walking speed x coordinate
int player_walk_y_speed;  // Initial walking speed y coordinate
int player_ani_speed;     // Initial animation speed
bool player_is_running;   // if character is currently running


bool player_frozen;       // player can't move
bool disabled_gui;        // GUI disabled
int action_button[ACT_COUNT];            // Array containing the verb button Ids
int action_button_normal[ACT_COUNT];     // contains the verb button sprites
int action_button_highlight[ACT_COUNT];  // Contains the highlighted verb button sprites
int button_action[ACT_COUNT];            // Array containg the related actions like eGA_LookAt

String tresult;           // translated result of the action mode, eg. "Look at %s"
String act_object;        // action_object - object used in action
String act_item;          // inventory item to be used or given 
int actionLabelWidth = 0; // Width of the action label in the status bar

int action_l_keycode[ACT_COUNT]; // lower case keycodes for the verbs
int action_u_keycode[ACT_COUNT]; // upper case keycodes for the verbs
InventoryItem*ItemGiven;        // Item given to a character
char key_l_yes, key_u_yes, key_l_no, key_u_no; // translated keys for yes and no

int  dc_speed;               // double click speed, set in the game start section
bool dc_timer_run;           // is doubleclick timer running
int  dc_timer_click;         // double click timer

int door_state[MAX_DOORS];// Array for the door script
String door_strings[6];   // default messages for the door script



// Default door sounds
AudioClip*  openDoorSound,   
            closeDoorSound, 
            unlockDoorSound; 
            
// ============================= Helper functions ===========================================

/***********************************************************************
 * Distance(int x1, int y1, int x2, int y2)
 * Returns the distance between two coordinates
 * 
 ***********************************************************************/
static float Verbs::Distance(int x1, int y1, int x2, int y2)
{
  int dx = x1 - x2;
  int dy = y1 - y2;
  return Maths.Sqrt(IntToFloat(dx*dx+dy*dy));
}

/***********************************************************************
 * Offset(int point1, int point2)
 * Returns the offset between to two given values.
 * 
 ***********************************************************************/
static int Verbs::Offset(int point1, int point2)
{
  int value = point1 - point2;
  
  if (value<0) return -value;
  else return value;
}

/***********************************************************************
 * GetButtonAction(int action)
 * Returns the connected action of a verb button.
 * 
 ***********************************************************************/
static int Verbs::GetButtonAction(int action) 
{
  return button_action[action];
}

/***********************************************************************
 * DisableGui()
 * This functions disables the GUI and hides it.
 * 
 ***********************************************************************/
static void Verbs::DisableGui()
{
  disabled_gui=true;
  gMain.Visible=false;
  gAction.Visible=false;
}

/***********************************************************************
 * EnableGui()
 * This functions enables the GUI and makes it visible.
 * 
 ***********************************************************************/
static void Verbs::EnableGui()
{
  disabled_gui=false;
  gMain.Visible=true;
  gAction.Visible=true;
  Wait(1);
}

/***********************************************************************
 * IsGuiDisabled()
 * Returns true, if the GUI is currently disabled, false otherwise
 * 
 ***********************************************************************/
static bool Verbs::IsGuiDisabled() 
{
  return disabled_gui;
}

/***********************************************************************
 * SetDoubleClickSpeed(int speed)
 * Defines the double click speed
 * 
 ***********************************************************************/
static void Verbs::SetDoubleClickSpeed(int speed)
{
  dc_speed = speed;
}

/***********************************************************************
 * HandleInvArrows() 
 * Takes care of showing or hiding the inventory scroll sprites
 *
 ***********************************************************************/
static void Verbs::HandleInvArrows()
{
  // change the arrows in the inventory to show if you
  // can scroll the inventory:
  if (invMain.TopItem > 0) {
    // if inventory can scroll up
    btnInvUp.NormalGraphic    = invUparrowONsprite;
    btnInvUp.MouseOverGraphic = invUparrowHIsprite;
    
    if (InventoryItem.GetAtScreenXY(gMain.X + invMain.X + 1, gMain.Y + invMain.Y + 1) == null) invMain.TopItem -= invMain.ItemsPerRow;
  }
  else { 
    btnInvUp.NormalGraphic    = invUparrowOFFsprite;
    btnInvUp.MouseOverGraphic = invUparrowOFFsprite;
  }
  //if inv can scroll down
  if (invMain.TopItem < invMain.ItemCount-(invMain.ItemsPerRow * invMain.RowCount)) { 
    btnInvDown.NormalGraphic    = invDownarrowONsprite;
    btnInvDown.MouseOverGraphic = invDownarrowHIsprite;
  }
  else{
    btnInvDown.NormalGraphic    = invDownarrowOFFsprite;
    btnInvDown.MouseOverGraphic = invDownarrowOFFsprite;
  }
}

// ============================= door init functions ===========================================

/***********************************************************************
 * SetDoorState(int door_id, int value) 
 * Call this function to set a door state for the given door_id. A door can have 3 different states:
 *  0 = The door is closed 
 *  1 = The door is open 
 *  2 = The door is closed and locked 
 * 
 ***********************************************************************/
static void Doors::SetDoorState(int door_id, int value) 
{
  door_state[door_id] = value;
}

/***********************************************************************
 * GetDoorState(int door_id) 
 * Returns the current state of a door.
 * 
 ***********************************************************************/
static int Doors::GetDoorState(int door_id) 
{
  return door_state[door_id];
}

/***********************************************************************
 * InitObject (int door_id, int obj)
 * Used to set up the corresponding object, used by the door with the given id. 
 * If the state of the door is closed, the object will be invisible. 
 * Otherwise, the object will be shown. The object stays unclickable all the time.
 *
 ***********************************************************************/
static void Doors::InitObject (int door_id, int obj)
{
  if (Doors.GetDoorState(door_id) == 1) {
    object[obj].Visible=true;
    object[obj].Clickable=false;
  }
  else { 
    object[obj].Visible=false;
    object[obj].Clickable=false;
  }
}

/***********************************************************************
 * SetDoorStrings(String lookat, String islocked, String wrongitem, String closefirst, String unlock, String relock)
 * Use this function to define the messages, the player character says, when approaching a door.
 * 
 ***********************************************************************/
static void Doors::SetDoorStrings(String lookat, String islocked, String wrongitem, String closefirst, String unlock, String relock) {
  if (!String.IsNullOrEmpty(lookat))     door_strings[0]=lookat;
  if (!String.IsNullOrEmpty(islocked))   door_strings[1]=islocked;
  if (!String.IsNullOrEmpty(wrongitem))  door_strings[2]=wrongitem;
  if (!String.IsNullOrEmpty(closefirst)) door_strings[3]=closefirst;
  if (!String.IsNullOrEmpty(unlock))     door_strings[4]=unlock;
  if (!String.IsNullOrEmpty(relock))     door_strings[5]=relock;
}

/***********************************************************************
 * GetDoorStrings(String what_type)
 * Returns the message, which has been set up by set_door_strings
 * 
 ***********************************************************************/
static String Doors::GetDoorStrings(String what_type) {
  String ret_value;
  
       if (what_type == "lookat")     ret_value= door_strings[0];
  else if (what_type == "islocked")   ret_value= door_strings[1];
  else if (what_type == "wrongitem")  ret_value= door_strings[2];
  else if (what_type == "closefirst") ret_value= door_strings[3];
  else if (what_type == "unlock")     ret_value= door_strings[4];
  else if (what_type == "relock")     ret_value= door_strings[5];
  else ret_value= "INVALID STRING";
  
  if (String.IsNullOrEmpty(ret_value)) return "";
  else return ret_value;
}


// ============================= verb action functions ===========================================

/***********************************************************************
 * TranslateAction(int action, int tr_lang)
 * This function defines the text for the verb buttons, e.g. if you click on the talk verb button, 
 * "Talk to" is being displayed in the action/status bar. The second parameter defines the returned language. 
 * If you want to customize this text, you have to edit this function.
 * 
 ***********************************************************************/
static void Verbs::TranslateAction(int action, int tr_lang) 
{
  if (tr_lang == eLangDE) {
    if (action == eGA_WalkTo)        tresult="Gehe zu %s";
    else if (action == eGA_LookAt)   tresult="Schau %s an";
    else if (action == eGA_TalkTo)   tresult="Rede mit %s";
    else if (action == eGA_GiveTo) {
      if (act_item.Length > 0)       tresult="Gib !s an %s";
      else                           tresult="Gib %s";
    }
    else if (action == eGA_PickUp)   tresult="Nimm %s";
    else if (action == eGA_Use) {
      if (act_item.Length > 0)       tresult="Benutze !s mit %s";
      else                           tresult="Benutze %s";
    }
    else if (action == eGA_Open)     tresult="Öffne %s";
    else if (action == eGA_Close)    tresult="Schließe %s";
    else if (action == eGA_Push)     tresult="Drücke %s";
    else if (action == eGA_Pull)     tresult="Ziehe %s";
    else tresult=" ";   
  }
  else if (tr_lang == eLangES) {
    if (action == eGA_WalkTo)        tresult="Ir a %s";
    else if (action == eGA_LookAt)   tresult="Mirar %s";
    else if (action == eGA_TalkTo)   tresult="Hablar con %s";
    else if (action == eGA_GiveTo) {
      if (act_item.Length > 0)       tresult="Dar !s a %s";
      else                           tresult="Dar %s";
    }
    else if (action == eGA_PickUp)   tresult="Coger %s";
    else if (action == eGA_Use) {
      if (act_item.Length > 0)       tresult="Usar !s con %s";
      else                           tresult="Usar %s";
    }
    else if (action == eGA_Open)     tresult="Abrir %s";
    else if (action == eGA_Close)    tresult="Cerrar %s";
    else if (action == eGA_Push)     tresult="Empujar %s";
    else if (action == eGA_Pull)     tresult="Tirar de %s";
    else tresult=" ";    
  }
  else if (tr_lang == eLangFR) {
    if (action == eGA_WalkTo)        tresult="Aller vers %s";
    else if (action == eGA_LookAt)   tresult="Regarder %s";
    else if (action == eGA_TalkTo)   tresult="Parler à %s";
    else if (action == eGA_GiveTo) {
      if (act_item.Length>0)         tresult="Donner !s à %s";
      else                           tresult="Donner %s";
    }
    else if (action == eGA_PickUp)   tresult="Prendre %s";
    else if (action == eGA_Use) {
      if (act_item.Length>0)         tresult="Utiliser !s sur %s";
      else                           tresult="Utiliser %s";
    }
    else if (action == eGA_Open)     tresult="Ouvrir %s";
    else if (action == eGA_Close)    tresult="Fermer %s";
    else if (action == eGA_Push)     tresult="Pousser %s";
    else if (action == eGA_Pull)     tresult="Tirer %s";
    else tresult=" "; 
  }  
  else if (tr_lang == eLangIT) {
    if (action == eGA_WalkTo)        tresult="Vai a %s";
    else if (action == eGA_LookAt)   tresult="Esamina %s";
    else if (action == eGA_TalkTo)   tresult="Parla con %s";
    else if (action == eGA_GiveTo) {
    if (act_item.Length > 0)         tresult="Dai !s a %s";
    else                             tresult="Dai %s";
    }
    else if (action == eGA_PickUp)   tresult="Raccogli %s";
    else if (action == eGA_Use) {
    if (act_item.Length > 0)         tresult="Usa !s con %s";
    else                             tresult="Usa %s";
    }
    else if (action == eGA_Open)     tresult="Apri %s";
    else if (action == eGA_Close)    tresult="Ferma %s";
    else if (action == eGA_Push)     tresult="Premi %s";
    else if (action == eGA_Pull)     tresult="Tira %s";
    else tresult=" "; 
  }
  else if (tr_lang == eLangPT) {
    if (action == eGA_WalkTo)        tresult="Ir para %s";
    else if (action == eGA_LookAt)   tresult="Olhar para %s";
    else if (action == eGA_TalkTo)   tresult="Falar com %s";
    else if (action == eGA_GiveTo) {
    if (act_item.Length > 0)         tresult="Dar !s a %s";
    else                             tresult="Dar %s";
    }
    else if (action == eGA_PickUp)   tresult="Apanhar %s";
    else if (action == eGA_Use) {
    if (act_item.Length > 0)         tresult="Usar !s com %s";
    else                             tresult="Usar %s";
    }
    else if (action == eGA_Open)     tresult="Abrir %s";
    else if (action == eGA_Close)    tresult="Fechar %s";
    else if (action == eGA_Push)     tresult="Empurrar %s";
    else if (action == eGA_Pull)     tresult="Puxar %s";
    else tresult=" "; 
  }
  else if (tr_lang == eLangNL) {
    if (action == eGA_WalkTo)        tresult="Ga naar %s";
    else if (action == eGA_LookAt)   tresult="Bekijk %s";
    else if (action == eGA_TalkTo)   tresult="Praat met %s";
    else if (action == eGA_GiveTo) {
    if (act_item.Length>0)           tresult="Geef !s aan %s";
    else                             tresult="Geef %s";
    }
    else if (action == eGA_PickUp)   tresult="Pak %s";
    else if (action == eGA_Use) {
    if (act_item.Length>0)           tresult="Gebruik !s met %s";
    else                             tresult="Gebruik %s";
    }
    else if (action == eGA_Open)     tresult="Open %s";
    else if (action == eGA_Close)    tresult="Sluit %s";
    else if (action == eGA_Push)     tresult="Duw %s";
    else if (action == eGA_Pull)     tresult="Trek %s";
    else tresult=" "; 
  }   
  else {
    if (action == eGA_WalkTo)        tresult="Walk to %s";
    else if (action == eGA_LookAt)   tresult="Look at %s";
    else if (action == eGA_TalkTo)   tresult="Talk to %s";
    else if (action == eGA_GiveTo) {
      if (act_item.Length > 0)       tresult="Give !s to %s";
      else                           tresult="Give %s";
    }
    else if (action == eGA_PickUp)   tresult="Pick up %s";
    else if (action == eGA_Use) {
      if (act_item.Length > 0)       tresult="Use !s with %s";
      else                           tresult="Use %s";
    }
    else if (action == eGA_Open)     tresult="Open %s";
    else if (action == eGA_Close)    tresult="Close %s";
    else if (action == eGA_Push)     tresult="Push %s";
    else if (action == eGA_Pull)     tresult="Pull %s";
    else tresult=" ";    
  }
  // fill object and item into action template
  tresult = GetTranslation(tresult);
  int ip = tresult.IndexOf("!s");
  if (ip >= 0) {
    int op  = tresult.Contains("%s");
    tresult = tresult.ReplaceCharAt(ip, '%');
    if (ip < op) tresult=String.Format(tresult, act_item, act_object);
    else         tresult=String.Format(tresult, act_object, act_item);
  }
  else {
    if (act_object == null) act_object = "";
    tresult=String.Format(tresult, act_object);
  }
}

/***********************************************************************
 * IsAction(Action test_action) 
 * Used to check, if the current action is the one, given in the parameter.
 * 
 ***********************************************************************/
static bool Verbs::IsAction(Action test_action) 
{
  return global_action == test_action;
}

/***********************************************************************
 * UsedAction(Action test_action) 
 * Used to determine, which action has been selected by the player. 
 * Instead of checking cursor modes, this function is used.
 * 
 ***********************************************************************/
static bool Verbs::UsedAction(Action test_action) 
{
  return ((used_action == test_action) && (AGSCursorMode != eModeUseinv)) || 
         ((test_action == eGA_UseInv)  && (used_action == eGA_Use) && (AGSCursorMode == eModeUseinv)) || 
         ((test_action == eGA_GiveTo)  && (used_action == eGA_GiveTo) && (AGSCursorMode == eModeUseinv) && ItemGiven!=null);
}

/***********************************************************************
 * SetAction(Action new_action) 
 * Since the cursor modes are bypassed, this function defines the current action. 
 * Among other things, this function is called by clicking a verb button.
 * 
 ***********************************************************************/
static void Verbs::SetAction(Action new_action) 
{
  // set default action
  if (new_action == eGA_Default) new_action=default_action;
  // set corresponding cursormode
       if (new_action == eGA_WalkTo) mouse.Mode=eModeUsermode2;
  else if (new_action == eGA_LookAt) mouse.Mode=eModeLookat;
  else if (new_action == eGA_TalkTo) mouse.Mode=eModeTalkto;
  else if (new_action == eGA_GiveTo) mouse.Mode=eModeInteract;
  else if (new_action == eGA_PickUp) mouse.Mode=eModePickup;
  else if (new_action == eGA_Use)    mouse.Mode=eModeInteract;
  else if (new_action == eGA_Open)   mouse.Mode=eModeUsermode1;
  else if (new_action == eGA_Close)  mouse.Mode=eModeUsermode1;
  else if (new_action == eGA_Push)   mouse.Mode=eModeUsermode1;
  else if (new_action == eGA_Pull)   mouse.Mode=eModeUsermode1;
  // save action
  global_action=new_action;
}

/***********************************************************************
 * SetDefaultAction(Action def_action) 
 * Used to define, which action is being used, if no verb has been clicked. 
 * Usually this is “walk to”.
 * 
 ***********************************************************************/
static void Verbs::SetDefaultAction(Action def_action) 
{
  default_action = def_action;
  Verbs.SetAction(eGA_Default);
}


// ============================= GlobalCondition ===========================================

/***********************************************************************
 * GlobalCondition(eGlobCond condition)
 * Used to check for conditions that are used many times in the script. 
 * For example, it’s used to check, if the mouse cursor is in the inventory and the mode walk or pickup are selected. 
 * Returns 1, if the condition is true and 0 otherwise.
 * 
 ***********************************************************************/
static int Verbs::GlobalCondition(eGlobCond condition) 
{
  // here are some conditions that are used many times in the script
  int cond;
  InventoryItem*ii = InventoryItem.GetAtScreenXY(mouse.x, mouse.y);
  GUIControl*gc    = GUIControl.GetAtScreenXY(mouse.x, mouse.y);
  int gcid = -1;
  if (gc != null) gcid = gc.ID;
  
  // if the mouse is in the inventory and mode Walk is selected
  if (condition == eGlob_MouseInvWalk ) {
    cond = (ii != null && (Verbs.IsAction(eGA_WalkTo)));
  }
  // if the mouse is in the inventory and mode Pickup is selected
  else if (condition == eGlob_MouseInvPickup) {
    cond = (ii != null && (Verbs.IsAction(eGA_PickUp)));
  }
  // if the mode is useinv and the mouse is over the active inv (like "use knife on knife")
  else if (condition == eGlob_InvOnInv) {
    cond =(player.ActiveInventory == ii && Mouse.Mode == eModeUseinv);
  } 
  // if the mode is talk or "Give", and the mouse isnt over a character
  else if (condition == eGlob_GiveTalkNoChar) {
    
    if (objHotTalk && Verbs.IsAction(eGA_TalkTo) ) {
      cond = false;     
    }  
    else {
      cond =((Verbs.IsAction(eGA_TalkTo) || (Verbs.IsAction(eGA_GiveTo) && (Mouse.Mode == eModeUseinv))) && (GetLocationType(mouse.x, mouse.y) != eLocationCharacter));
    }
  }
    
  // if its GIVE and the mouse isnt over a inv.item
  else if (condition == eGlob_GiveNoInv) 
    cond = ((Mouse.Mode == eModeInteract) && Verbs.IsAction(eGA_GiveTo) && (ii == null));
  
  // if the mouse is in the inventory and mode TalkTo is selected 
  else if (condition == eGlob_InvTalk)
    cond =  (ii != null && (Verbs.IsAction(eGA_TalkTo)));
  
  return cond;
}

// ============================= Verb Extensions and actions ===========================================

/***********************************************************************
 * ExtensionEx(int index, String name)
 * Returns the n-th extension of the given string. 
 * 
 ***********************************************************************/
static char Verbs::ExtensionEx(int index, String name)
{
  //returns the extension in the position 'index' of the string 'name'.
  //returns 0 if the name has no extension or if you passed an empty string.
  if (name.Length == 0) return 0;//if you passed an empty string
  int pos;
  pos = name.IndexOf(">");
  if (pos == -1) return 0;
  else if (pos+index<name.Length) return name.Chars[pos+index];
  else return 0;
}

/***********************************************************************
 * Extension()
 * Returns the first extention of the location
 * 
 ***********************************************************************/
static char Verbs::Extension()
{
  // Check the (first) extension (>*) of a string
  return Verbs.ExtensionEx(1, location);
}

/***********************************************************************
 * RemoveExtension()
 * Used to remove the extension from a location (Hotspots, Objects etc.), so it doesn’t get displayed in the status bar.
 * 
 ***********************************************************************/
static int Verbs::RemoveExtension()
{
  //removes the extension of a string  
  int pos = location.IndexOf(">");
  int length = location.Length;
  if (Verbs.Extension() != 0) location = location.Truncate(pos);
  return pos;
}

/***********************************************************************
 * AddExtension()
 * Used to add a default extension in case the location doesn’t have one.
 * 
 ***********************************************************************/
static void Verbs::AddExtension(char extension) 
{
  //adds an extension to a thing that doesn't have one
  int length=location.Length;
  if (Verbs.Extension() == 0) {
    location=location.Append(">n");
    location=location.ReplaceCharAt(length+1, extension);
  }
}

/***********************************************************************
 * SetAlternativeAction(char extension, Action alt_action)
 * This function makes the right-click shortcuts work. 
 * If you use extensions like “>p” (e.g. pickup), this function makes sure, that the correct verb button is highlighted.
 * 
 ***********************************************************************/
static void Verbs::SetAlternativeAction(char extension, Action alt_action) 
{
  if (alt_action == eGA_Default) {
    if (Verbs.Extension() == extension)
      alternative_action = alt_action;
  }
  else {
    int button          = action_button[alt_action];
    int normalbuttonpic = action_button_normal[alt_action];
    int overbuttonpic   = action_button_highlight[alt_action];
    
    // used for setting the default action given the extension.
    GUIControl*gc = gMain.Controls[button];
    Button*b = gc.AsButton;
    
    if (Verbs.Extension() == extension) {
      b.NormalGraphic = overbuttonpic;
      alternative_action = alt_action;
    }
    else b.NormalGraphic = normalbuttonpic;
    b.MouseOverGraphic = overbuttonpic;
  }
}

/***********************************************************************
 * OpenCloseExtension(int door_id)
 * Used in combination with the door scripts. This function returns a close extension, if the door with the given id is open and vice versa.
 * 
 ***********************************************************************/
static void Verbs::OpenCloseExtension(int door_id) 
{
  if ((Doors.GetDoorState(door_id)==0) || (Doors.GetDoorState(door_id)==2)) Verbs.AddExtension('o');
  else Verbs.AddExtension('c');
}

/***********************************************************************
 * VariableExtensions(
 * This function is called, if you have have set "v" as an extension for a certain location. 
 * Currently it is used for the OpenClose extension, but of course you can add your own variable extensions here, 
 * for example "turn on / turn off"
 * 
 ***********************************************************************/
static void Verbs::VariableExtensions() 
{
  // define here, which things will use a variable extension (>v)
  // by default, it's only used for doors.
  int r = player.Room;
  Object*oo = Object.GetAtScreenXY(mouse.x, mouse.y);
  int o=0;
  if (oo != null) o = oo.ID;
  Hotspot*hh = Hotspot.GetAtScreenXY(mouse.x, mouse.y);
  int h = hh.ID;
  
  // Other possible extensions could be: Turn On/Turn Off
  
  // Open/Close Extension:
  // Room | Hotspot |(Door_id)
  if (r==2 && h == 1)  Verbs.OpenCloseExtension (10);
  //else if (r==2  && h == 2)  OpenCloseExtension (3);  
}

/***********************************************************************
 * CheckDefaultAction()
 * This function checks for a given extension in hotspots, objects and characters. 
 * If there isn’t an extension, a default action is given, e.g. “Talk to” if the mouse is over a character. 
 * In case of a given extension, the default actions are being overridden.
 * 
 ***********************************************************************/
static void Verbs::CheckDefaultAction() 
{
  // you could want to change which extension activates which default action, or which button sprite
  // it changes. The extensions are characters, so remember enclose them in single quotes ' , not double quotes ".
  int x = mouse.x;
  int y = mouse.y;
  
  location = Game.GetLocationName(x, y);
  location_ex = location;
  
  
  // Setting default modes if the thing has no extension:
  if (Verbs.Extension() == 0 ) {
    if (GetLocationType(x, y) == eLocationCharacter) // if it is a character
      Verbs.AddExtension('t'); // set default action "talk to"
    else if ((GetLocationType(x, y) != eLocationNothing) || (InventoryItem.GetAtScreenXY(x, y)!=null))
      // if its an inv item, a hotspot or an object
      Verbs.AddExtension('l'); // set default action "look at"
    else
      Verbs.AddExtension('n'); // set default action "none"
  }
  else if (Verbs.Extension()=='v') { // if the default action depends on some events
    Verbs.RemoveExtension();
    Verbs.VariableExtensions();
  }
  if (Verbs.GlobalCondition(eGlob_InvOnInv) || (!objHotTalk && Verbs.GlobalCondition(eGlob_GiveTalkNoChar)) || Verbs.GlobalCondition(eGlob_GiveNoInv) ) {
    //Dont send the name of the hotspt/obj/char/inv to the action bar and set default action "none"
    if (!Verbs.GlobalCondition(eGlob_InvTalk)) location=">n";
  }
  
  inv_ex_location=location;
  
  // Set "Look" as default action for Inv items
  if ((Verbs.Extension()=='u') && (InventoryItem.GetAtScreenXY(x, y) != null)) {
    // it's an inv item
    Verbs.RemoveExtension();
    Verbs.AddExtension('l'); // set default action "look at"
  }
  
  Verbs.SetAlternativeAction('n', eGA_Default);
  Verbs.SetAlternativeAction('g', eGA_GiveTo);
  Verbs.SetAlternativeAction('p', eGA_PickUp);
  Verbs.SetAlternativeAction('u', eGA_Use);
  Verbs.SetAlternativeAction('o', eGA_Open);
  Verbs.SetAlternativeAction('l', eGA_LookAt);
  Verbs.SetAlternativeAction('s', eGA_Push);
  Verbs.SetAlternativeAction('c', eGA_Close);
  Verbs.SetAlternativeAction('t', eGA_TalkTo);
  Verbs.SetAlternativeAction('y', eGA_Pull);  
  Verbs.RemoveExtension();
  inv_location = location;
}
// ============================= ActionBar ===========================================


/***********************************************************************
 * AdjustActionBarPosition()
 * Moves the action label above the mouse cursor
 * 
 ***********************************************************************/
static void Verbs::AdjustActionBarPosition()
{
  int actionLabelHalf = actionLabelWidth / 2;
  int xpos = mouse.x - actionLabelHalf ;
  int ypos = mouse.y - Game.SpriteHeight[mouse.GetModeGraphic(mouse.Mode)] - 4;
  
  if (xpos + actionLabelWidth >= System.ScreenWidth) xpos = System.ScreenWidth - actionLabelWidth;
  else if (xpos < 0) xpos = 0;
  
  if (ypos < 0 ) ypos = 0;
  
  lblAction.X = xpos;
  lblAction.Y = ypos;
  lblAction.Width = actionLabelWidth;
  
}

/***********************************************************************
 * UpdateActionBar()
 * This function is used to show and update the status bar. 
 * It checks for an extension, triggers the translation and renders the results on screen.
 * 
 ***********************************************************************/
static void Verbs::UpdateActionBar() 
{
  // set the text in the action bar
  int action = global_action;
  act_object = inv_location;  
  act_item = "";
  
  if (Mouse.Mode==eModeUseinv) { // use or give inventory item
    act_item = player.ActiveInventory.Name;
    location = act_item;
    Verbs.RemoveExtension();
    act_item = location;
  }
  // if the mouse is in the inventory and modes Walk or pickup are selected
  else if (Verbs.GlobalCondition(eGlob_MouseInvWalk)) { 
      action = eGA_Use;
  }
  
  Verbs.TranslateAction(action, lang);
  // show action text
  if (!classicGui && act_object == "" && action == eGA_WalkTo) lblAction.Text = " ";
  else lblAction.Text=tresult;
  
  lblAction.TextColor = actionLabelColorNormal;
  actionLabelWidth = GetTextWidth(lblAction.Text, eFontTextOut) + 4; //+4 because GetTextWidth doesn't work too well with automatic outlined fonts
  
  if (lblAction.Width != System.ScreenWidth) {   
    lblAction.Width = System.ScreenWidth;
    lblAction.Y = gMain.Y - lblAction.Height;
  }
  
  // Show option button
  if ( mouse.x > System.ScreenWidth - btnShowOptions.Width +1 && mouse.y < btnShowOptions.Height +1 ) {
    btnShowOptions.Visible = true;
    gAction.Clickable = true;
  }
  else {
    gAction.Clickable = false;
    btnShowOptions.Visible = false;
  }
  
}

/***********************************************************************
 * ToogleGuiStyle(int enable_new)
 * Switches between classic Scumm mode and new one.
 * 
 ***********************************************************************/
static void Verbs::ToogleGuiStyle(int enable_new)
{
  if (enable_new == 1) {
    classicGui = false;
    Verbs.AdjustActionBarPosition();
  }
  else {
    classicGui = true;
    lblAction.Width = System.ScreenWidth;
    lblAction.X = 0;
    lblAction.Y = gMain.Y - lblAction.Height ;
  }
  Verbs.UpdateActionBar();
}
  

// ============================= translation ===========================================

/***********************************************************************
 * SetActionButtons(Action action, int btn_ID, int sprite, int sprite_highlight, char key)
 * This functions connects the verb buttons with the action and is also used to assign / change the graphics of the verb buttons.
 * 
 ***********************************************************************/
static void Verbs::SetActionButtons(Action action, int btn_ID, int sprite, int sprite_highlight, char key)
{
  String upperkey = String.Format("%c", key);
  upperkey = upperkey.UpperCase();
  
  action_button[action] = btn_ID;
  action_button_normal[action] = sprite;
  action_button_highlight[action] = sprite_highlight;
  action_l_keycode[action] = key;
  action_u_keycode[action] = upperkey.Chars[0];
  button_action[action_button[action]]=action;
}


/***********************************************************************
 * AdjustLanguage() 
 * This sets up everything related to the verb buttons, so you need to take a look at this, if you want to customize your GUI. 
 * 
 ***********************************************************************/
static void Verbs::AdjustLanguage() 
{
  // English
  if (lang == eLangEN) {
    // yes/no-keys
    key_u_yes= 'Y';
    key_l_yes= 'y';
    key_u_no= 'N';
    key_l_no= 'n';
    
    Verbs.SetActionButtons(eGA_Open,    0, 59, 60, 'q');
    Verbs.SetActionButtons(eGA_Close,   1, 61, 62, 'a');
    Verbs.SetActionButtons(eGA_GiveTo,  2, 63, 64, 'z');
    Verbs.SetActionButtons(eGA_PickUp,  3, 71, 72, 'w');
    Verbs.SetActionButtons(eGA_LookAt,  4, 73, 74, 's');
    Verbs.SetActionButtons(eGA_TalkTo,  5, 75, 76, 'x');
    Verbs.SetActionButtons(eGA_Push,    6, 65, 66, 'e');
    Verbs.SetActionButtons(eGA_Pull,    7, 67, 68, 'd');
    Verbs.SetActionButtons(eGA_Use,     8, 69, 70, 'c');
    
  }
  
  // German
  else if (lang == eLangDE) {
    // yes/no-keys
    key_u_yes= 'J';
    key_l_yes= 'j';
    key_u_no= 'N';
    key_l_no= 'n';    
    Verbs.SetActionButtons(eGA_Open,    0, 94, 101, 'q');
    Verbs.SetActionButtons(eGA_Close,   1, 102, 103, 'a');
    Verbs.SetActionButtons(eGA_GiveTo,  2, 104, 105, 'y');
    Verbs.SetActionButtons(eGA_PickUp,  3, 112, 113, 'w');
    Verbs.SetActionButtons(eGA_LookAt,  4, 114, 115, 's');
    Verbs.SetActionButtons(eGA_TalkTo,  5, 116, 117, 'x');
    Verbs.SetActionButtons(eGA_Push,    6, 106, 107, 'e');
    Verbs.SetActionButtons(eGA_Pull,    7, 108, 109, 'd');
    Verbs.SetActionButtons(eGA_Use,     8, 110, 111, 'c');
  }
  
  // Spanish
  else if (lang == eLangES) {
    // yes/no-keys
    key_u_yes= 'S';
    key_l_yes= 's';
    key_u_no= 'N';
    key_l_no= 'n';     

    Verbs.SetActionButtons(eGA_Open,    0, 141, 142, 'q');
    Verbs.SetActionButtons(eGA_Close,   1, 143, 144, 'a');
    Verbs.SetActionButtons(eGA_GiveTo,  2, 145, 146, 'y');
    Verbs.SetActionButtons(eGA_PickUp,  3, 153, 154, 'w');
    Verbs.SetActionButtons(eGA_LookAt,  4, 155, 156, 's');
    Verbs.SetActionButtons(eGA_TalkTo,  5, 157, 158, 'x');
    Verbs.SetActionButtons(eGA_Push,    6, 148, 147, 'e');
    Verbs.SetActionButtons(eGA_Pull,    7, 149, 150, 'd');
    Verbs.SetActionButtons(eGA_Use,     8, 151, 152, 'c');
  }  
  // French
  else if (lang == eLangFR) {
    // yes/no-keys
    key_u_yes= 'O';
    key_l_yes= 'o';
    key_u_no= 'N';
    key_l_no= 'n';   
    
    Verbs.SetActionButtons(eGA_Open,    0, 123, 124, 'q');
    Verbs.SetActionButtons(eGA_Close,   1, 125, 126, 'a');
    Verbs.SetActionButtons(eGA_GiveTo,  2, 127, 128, 'y');
    Verbs.SetActionButtons(eGA_PickUp,  3, 135, 136, 'w');
    Verbs.SetActionButtons(eGA_LookAt,  4, 137, 138, 's');
    Verbs.SetActionButtons(eGA_TalkTo,  5, 139, 140, 'x');
    Verbs.SetActionButtons(eGA_Push,    6, 129, 130, 'e');
    Verbs.SetActionButtons(eGA_Pull,    7, 131, 132, 'd');
    Verbs.SetActionButtons(eGA_Use,     8, 133, 134, 'c'); 
  }    
  // Italian
  else if (lang == eLangIT) {
    // yes/no-keys
    key_u_yes= 'S';
    key_l_yes= 's';
    key_u_no= 'N';
    key_l_no= 'n';     

    Verbs.SetActionButtons(eGA_Open,    0, 159, 160, 'q');
    Verbs.SetActionButtons(eGA_Close,   1, 161, 162, 'a');
    Verbs.SetActionButtons(eGA_GiveTo,  2, 163, 164, 'y');
    Verbs.SetActionButtons(eGA_PickUp,  3, 171, 172, 'w');
    Verbs.SetActionButtons(eGA_LookAt,  4, 173, 174, 's');
    Verbs.SetActionButtons(eGA_TalkTo,  5, 175, 176, 'x');
    Verbs.SetActionButtons(eGA_Push,    6, 165, 166, 'e');
    Verbs.SetActionButtons(eGA_Pull,    7, 167, 168, 'd');
    Verbs.SetActionButtons(eGA_Use,     8, 169, 170, 'c'); 
  }
  else if (lang == eLangPT) {
    // yes/no-keys
    key_u_yes= 'S';
    key_l_yes= 's';
    key_u_no= 'N';
    key_l_no= 'n';     

    Verbs.SetActionButtons(eGA_Open,    0, 177, 178, 'q');
    Verbs.SetActionButtons(eGA_Close,   1, 179, 180, 'a');
    Verbs.SetActionButtons(eGA_GiveTo,  2, 181, 182, 'y');
    Verbs.SetActionButtons(eGA_PickUp,  3, 189, 190, 'w');
    Verbs.SetActionButtons(eGA_LookAt,  4, 191, 192, 's');
    Verbs.SetActionButtons(eGA_TalkTo,  5, 193, 194, 'x');
    Verbs.SetActionButtons(eGA_Push,    6, 183, 184, 'e');
    Verbs.SetActionButtons(eGA_Pull,    7, 185, 186, 'd');
    Verbs.SetActionButtons(eGA_Use,     8, 187, 188, 'c'); 
  }
  // Dutch
  else if (lang == eLangNL) {
    // yes/no-keys
    key_u_yes= 'J';
    key_l_yes= 'j';
    key_u_no= 'N';
    key_l_no= 'n';    
    Verbs.SetActionButtons(eGA_Open,    0, 195, 196, 'q');
    Verbs.SetActionButtons(eGA_Close,   1, 197, 198, 'a');
    Verbs.SetActionButtons(eGA_GiveTo,  2, 199, 200, 'y');
    Verbs.SetActionButtons(eGA_PickUp,  3, 207, 208, 'w');
    Verbs.SetActionButtons(eGA_LookAt,  4, 209, 210, 's');
    Verbs.SetActionButtons(eGA_TalkTo,  5, 211, 212, 'x');
    Verbs.SetActionButtons(eGA_Push,    6, 201, 202, 'e');
    Verbs.SetActionButtons(eGA_Pull,    7, 203, 204, 'd');
    Verbs.SetActionButtons(eGA_Use,     8, 205, 206, 'c');
  }  
  
}


/***********************************************************************
 * AdjustGUIText() 
 * This sets up the translation for the other GUI elements
 * 
 ***********************************************************************/
static void Verbs::AdjustGUIText() 
{
  bool custom_font;
  int fontText    = eFontText;
  int fontTextOut = eFontTextOut;
  int fontSpeech  = eFontSpeech;
  int fontSpeechOut = eFontOutlineSpeech;
  
  // English
  if (lang == eLangEN){
    // english is the default language, nothing to adjust
  }
  
  else if (lang == eLangDE) {
    // German
    custom_font = false;
    /*
      // Just an example how you would define custom fonts:
      custom_font = true;
      fontText    = eFontLucasFan;
      fontTextOut = eFontLucasFanOut;    
    */
    lblOptions.Text   = "Optionen";
    lblOptionsMusic.Text   = "Musik Lautstärke";
    lblOptionsSound.Text   = "Sound Effekte";
    lblOptionsStyle.Text   = "Bedienung";
    lblOptionsGuiClassic.Text   = "Klassisch";
    lblOptionsGuiModern.Text    = "Modern";
    btnOptionsDefault.Text = "Standard";
    btnOptionsSave.Text    = "Speichern";
    btnOptionsLoad.Text    = "Laden";
    btnOptionsQuit.Text    = "Beenden";
    btnOptionsResume.Text  = "Weiter";
    lblPauseHeadline.Text  = "Pause";
    lblPauseMessage.Text   = "Leertaste für weiter";
    lblLoad.Text           = "Spielstand laden";
    btnLoadCancel.Text     = "Abbruch";
    lblSave.Text           = "Spielstand speichern";
    btnSaveCancel.Text     = "Abbruch";
    lblQuitHeadline.Text   = "Spiel verlassen";
    lblQuitMessage.Text    = "Möchten Sie das Spiel beenden?";
    btnQuitYes.Text        = "Ja";
    btnQuitNo.Text         = "Nein";
  }
  else if (lang == eLangES) {
    // Spanish
    custom_font = false;
    lblOptions.Text        = "Opciones";
    lblOptionsMusic.Text   = "Volumen de la música";
    lblOptionsSound.Text   = "Efectos de sonido ";
    lblOptionsStyle.Text   = "Diseño";
    lblOptionsGuiClassic.Text = "clásico";
    lblOptionsGuiModern.Text  = "moderno";    
    btnOptionsDefault.Text = "Restablecer";
    btnOptionsSave.Text    = "Guardar";
    btnOptionsLoad.Text    = "Cargar";
    btnOptionsQuit.Text    = "Salir";
    btnOptionsResume.Text  = "Volver";
    lblPauseHeadline.Text  = "Pausa";
    lblPauseMessage.Text   = "Pulsa Espacio para continuar";
    lblLoad.Text        = "Por favor, elige el juego a cargar";
    btnLoadCancel.Text  = "Cancelar";
    lblSave.Text        = "Por favor, introduce un nombre";
    btnSaveCancel.Text  = "Cancelar";
    lblQuitHeadline.Text = "¿Salir del juego?";
    lblQuitMessage.Text  = "¿Seguro que quieres salir?";
    btnQuitYes.Text     = "Si";
    btnQuitNo.Text      = "No";    
  }
  else if (lang == eLangFR) {
    // French
    custom_font = false;
    lblOptions.Text   = "Paramètres";
    lblOptionsMusic.Text   = "Volume de la musique";
    lblOptionsSound.Text   = "Volume des sons";
    lblOptionsStyle.Text   = "Style";
    lblOptionsGuiClassic.Text = "classique";
    lblOptionsGuiModern.Text  = "moderne";    
    btnOptionsDefault.Text = "Réinitialiser";
    btnOptionsSave.Text    = "Sauver";
    btnOptionsLoad.Text    = "Charger";
    btnOptionsQuit.Text    = "Quitter";
    btnOptionsResume.Text  = "Reprendre";
    lblPauseHeadline.Text  = "Pause";
    lblPauseMessage.Text   = "Appuyez sur la barre d'espacement pour reprendre";
    lblLoad.Text        = "Choisissez une partie à charger";
    btnLoadCancel.Text  = "Annuler";
    lblSave.Text        = "Saisissez un nom";
    btnSaveCancel.Text  = "Annuler";
    lblQuitHeadline.Text = "Quitter";
    lblQuitMessage.Text  = "Voulez-vous vraiment quitter?";
    btnQuitYes.Text     = "Oui";
    btnQuitNo.Text      = "No";    
  }  
  else if (lang == eLangIT) {
    // Italian
    custom_font = false;
    lblOptions.Text   = "Opzioni";
    lblOptionsMusic.Text   = "Volume della Musica";
    lblOptionsSound.Text   = "Effetti Sonori";
    lblOptionsStyle.Text   = "Disposizione";
    lblOptionsGuiClassic.Text = "classica";
    lblOptionsGuiModern.Text  = "moderna";     
    btnOptionsDefault.Text = "Risedersi";
    btnOptionsSave.Text    = "Salva";
    btnOptionsLoad.Text    = "Carica";
    btnOptionsQuit.Text    = "Esci";
    btnOptionsResume.Text  = "Continua";
    lblPauseHeadline.Text  = "Partita in Pausa";
    lblPauseMessage.Text   = "Premi Spazio per Continuare";
    lblLoad.Text         = "Scegli una partita da caricare";
    btnLoadCancel.Text   = "Cancella";
    lblSave.Text         = "Inserisci un nome";
    btnSaveCancel.Text   = "Cancella";
    lblQuitHeadline.Text = "Uscire dal gioco";
    lblQuitMessage.Text  = "Sei sicuro/a che vuoi uscire?";
    btnQuitYes.Text      = "Si";
    btnQuitNo.Text       = "No";     
  }
  else if (lang == eLangPT) {
    // Portuguese
    custom_font = false;
    lblOptions.Text   = "Opções";
    lblOptionsMusic.Text   = "Volume Música";
    lblOptionsSound.Text   = "Efeitos Sonoros";
    lblOptionsStyle.Text   = "Disposição";
    lblOptionsGuiClassic.Text = "clássica";
    lblOptionsGuiModern.Text  = "moderna";    
    btnOptionsDefault.Text    = "Standard";
    btnOptionsSave.Text    = "Gravar";
    btnOptionsLoad.Text    = "Restaurar";
    btnOptionsQuit.Text    = "Desistir";
    btnOptionsResume.Text  = "Continuar";
    lblPauseHeadline.Text  = "Pausa";
    lblPauseMessage.Text   = "Prima Space para continuar";
    lblLoad.Text           = "Por favor escolha um jogo";
    btnLoadCancel.Text     = "Cancelar";
    lblSave.Text         = "Por favor insira um nome";
    btnSaveCancel.Text   = "Cancelar";
    lblQuitHeadline.Text = "Desistir";
    lblQuitMessage.Text  = "De certeza que quer desistir?";
    btnQuitYes.Text      = "Si";
    btnQuitNo.Text       = "No";       
  }
  else if (lang == eLangNL) {
    // Dutch
    custom_font = false;
    lblOptions.Text   = "Opties";
    lblOptionsMusic.Text   = "Muziek Volume";
    lblOptionsSound.Text   = "Geluidseffecten";
    lblOptionsStyle.Text   = "Bediening";
    lblOptionsGuiClassic.Text   = "klassiek";
    lblOptionsGuiModern.Text    = "modern";
    btnOptionsDefault.Text = "Standaard";
    btnOptionsSave.Text    = "Opslaan";
    btnOptionsLoad.Text    = "Laden";
    btnOptionsQuit.Text    = "Stop";
    btnOptionsResume.Text  = "Ga door";
    lblPauseHeadline.Text  = "Pauze";
    lblPauseMessage.Text   = "Druk op de Spatiebalk om door te gaan";
    lblLoad.Text           = "Kies a.u.b. een spel om te laden";
    btnLoadCancel.Text     = "Annuleren";
    lblSave.Text           = "Vul a.u.b. een naam in";
    btnSaveCancel.Text     = "Annuleren";
    lblQuitHeadline.Text   = "Sluit spel af";
    lblQuitMessage.Text    = "Weet u zeker dat u wilt stoppen?";
    btnQuitYes.Text        = "Ja";
    btnQuitNo.Text         = "Nee";
  }  
  
  // Apply language dependend custom fonts if needed
  if (custom_font) {
    Game.SpeechFont   = fontSpeech;
    Game.NormalFont   = fontText;
    lblAction.Font    = fontTextOut;
    lblOptions.Font   = fontText;
    lblOptionsMusic.Font   = fontText;
    lblOptionsSound.Font   = fontText;
    lblOptionsStyle.Font   = fontText;
    lblOptionsGuiClassic.Font   = fontTextOut;
    lblOptionsGuiModern.Font    = fontTextOut;
    btnOptionsDefault.Font = fontText;
    btnOptionsSave.Font    = fontText;
    btnOptionsLoad.Font    = fontText;
    btnOptionsQuit.Font    = fontText;
    btnOptionsResume.Font  = fontText;
    lblPauseHeadline.Font  = fontText;
    lblPauseMessage.Font   = fontText;
    lblLoad.Font           = fontText;
    btnLoadCancel.Font     = fontText;
    lblSave.Font           = fontText;
    btnSaveCancel.Font     = fontText;
    lblQuitHeadline.Font   = fontText;
    lblQuitMessage.Font    = fontText;
    btnQuitYes.Font        = fontText;
    btnQuitNo.Font         = fontText;
  }
}

/***********************************************************************
 * InitGuiLanguage() 
 * Assigns the buttons graphics to the GUI elements
 * 
 ***********************************************************************/
static void Verbs::InitGuiLanguage() 
{
  Verbs.AdjustLanguage();
  int i;
  GUIControl*gc;
  Button*b;
  
  while (i < ACT_COUNT) {
    gc = gMain.Controls[action_button[i]];
    b =  gc.AsButton;
    b.NormalGraphic=action_button_normal[i];
    i++;
  }
}

// ============================= Player function ===========================================


/***********************************************************************
 * FreezePlayer() 
 * Use this function to prevent the player from moving by the following movement functions of the template.
 * 
 ***********************************************************************/
static void Verbs::FreezePlayer()
{
  player_frozen = true;
}

/***********************************************************************
 * UnfreezePlayer() 
 * Use this function to undo the freeze_player function and let the characters move again.
 * 
 ***********************************************************************/
static void Verbs::UnfreezePlayer()
{
  player_frozen = false;
}
  
/***********************************************************************
 * SetPlayer(Character*ch)  
 * Similar to the AGS function Character.SetAsPlayer(). The difference is, that make the previous character clickable again, whereas the new character gets unclickable.
 * 
 ***********************************************************************/
static void Verbs::SetPlayer(Character*ch) 
{
  // if old and new player character are in the same room then scroll room
  if (player.Room==ch.Room) { 
    int x = GetViewportX();
    int tx = ch.x - 160;
    if (tx < 0) tx = 0;
    else if (tx > Room.Width - 320) tx = Room.Width-320;
    SetViewport(x, GetViewportY());
    while (x<tx) {
      x += player_walk_x_speed;
      if (x > tx) x=tx;
      SetViewport(x, GetViewportY());
      Wait(1);
    }
    while (x > tx) {
      x -= player_walk_x_speed;
      if (x < tx) x=tx;
      SetViewport(x, GetViewportY());
      Wait (1);
    }
  }
  else // if they are in different rooms
    player.StopMoving();
    player.Clickable=true;
    ch.Clickable=false;
    ch.SetAsPlayer();
    ReleaseViewport();
}

/***********************************************************************
 * MovePlayerEx(int x, int y, WalkWhere direct)
 * Move the player character to x,y coords, waiting until he/she gets there,
 * but allowing to cancel the action by pressing a mouse button.
 * Return values:
 * 0 = movement cancelled
 * 1 = not cancelled
 * 2 = reached the given coordinates
 * 
 ***********************************************************************/
static int Verbs::MovePlayerEx(int x, int y, WalkWhere direct) 
{
  bool movement_canceled = false;
  // Move the player character to x,y coords, waiting until he/she gets there,
  // but allowing to cancel the action by pressing a mouse button.
  if (player_frozen == false) {
    player.Walk(x, y, eNoBlock, direct);
    // wait for release of mouse button
    while (player.Moving && (mouse.IsButtonDown(eMouseLeft) || mouse.IsButtonDown(eMouseRight))) {
      Wait(1);
      mouse.Update();
      Verbs.CheckDefaultAction();
    }
    // abort moving on new mouse down
    while (player.Moving) {
      int xm = mouse.x;
      int ym = mouse.y;
      InventoryItem*ii = InventoryItem.GetAtScreenXY(xm, ym);
      if (mouse.IsButtonDown(eMouseLeft) && (GUI.GetAtScreenXY(xm, ym)==null || ii!=null)) {
        player.StopMoving();
        movement_canceled = true;
      }
      else if (mouse.IsButtonDown(eMouseRight) && (GUI.GetAtScreenXY(xm, ym)==null || ii!=null)) {
        player.StopMoving();
        movement_canceled = true;
      }
      else {
        Wait(1);
        mouse.Update();
        Verbs.CheckDefaultAction ();
      }
    }
    if (!movement_canceled && player.x == x && player.y == y) return 2;
    else if (!movement_canceled) return 1;
    else return 0;
  }
  else return 0;
}

/***********************************************************************
 * MovePlayer(int x, int y)
 * Moves the player character around on walkable areas, a wrapper for MovePlayerEx.
 * 0 = movement cancelled
 * 1 = if the character has reached the given coordinates
 * 
 ***********************************************************************/
static int Verbs::MovePlayer(int x, int y) 
{
  //Move the player character to x,y coords, waiting until he/she gets there, but allowing to cancel the action
  //by pressing a mouse button.
  return Verbs.MovePlayerEx (x, y, eWalkableAreas);
}


/***********************************************************************
 * GoToCharacterEx(Character*chwhogoes, Character*ch, CharacterDirection dir, int xoffset, int yoffset, bool NPCfacesplayer, int blocking)
 * Goes to a character staying at the side defined by ‘direction’: 1 up, 2 right, 3 down, 4 left and it stays at x-offset or y-offset from the character. 
 * blocking: 0=non-blocking; 1=blocking; 2=semi-blocking 
 * Returns 1, if the character has reached it’s goal and 0 if the movement has been cancelled before.
 * 
 ***********************************************************************/
static int Verbs::GoToCharacterEx(Character*chwhogoes, Character*ch, CharacterDirection dir, int xoffset, int yoffset, bool NPCfacesplayer, int blocking) 
{
  Character*pl = chwhogoes;
  int chx, chy;
  chx = ch.x;
  chy = ch.y;
  int arrived=1;
  if (Verbs.Offset(pl.x, chx) > xoffset || Verbs.Offset(pl.y, chy) > yoffset) {
    if (dir == 0) {
      // get the nearest position
      if (Verbs.Offset (chx, pl.x) >= Verbs.Offset(chy, pl.y)) {
        // right or left
        if (pl.x >= chx) dir = eDirectionRight;
        else dir = eDirectionLeft;
      }
      else {
        if (pl.y >= chy) dir = eDirectionDown; 
        else dir = eDirectionUp;
      }
    }
    // calculate target position
    if (dir == eDirectionUp)    chy-=yoffset;
    else if (dir == eDirectionRight) chx+=xoffset;
    else if (dir == eDirectionDown)  chy+=yoffset;
    else if (dir == eDirectionLeft)  chx-=xoffset;
    // move character
    if (blocking==0) {
      pl.Walk(chx, chy);
      arrived = 0;
    }
    else if (blocking==1) {
      pl.Walk(chx, chy, eBlock, eWalkableAreas);
      arrived=1;
    }
    else if (blocking==2) arrived=Verbs.MovePlayer(chx, chy);
  }
  if (arrived>0) {
    // characters only face each other after the moving character arrived at the target point
    if (NPCfacesplayer) ch.FaceCharacter(pl, eBlock);
    pl.FaceCharacter(ch, eBlock);
  }
  return arrived;
}

/***********************************************************************
 * NPCGoToCharacter(Character*chwhogoes, Character*chtogoto, CharacterDirection dir, bool NPCfacesplayer, int blocking)
 * The same as GoToCharacterEx, just with an default offset of x=35 and y=20 
 * blocking: 0=non-blocking; 1=blocking; 2=semi-blocking 
 * Returns 1, if the character has reached it’s goal and 0 if the movement has been cancelled before.
 * 
 ***********************************************************************/
static int Verbs::NPCGoToCharacter(Character*chwhogoes, Character*chtogoto, CharacterDirection dir, bool NPCfacesplayer, int blocking) 
{
  // same as above but with default x and y offset.
  int defaultxoffset = 35;
  int defaultyoffset = 20;
  return Verbs.GoToCharacterEx (chwhogoes, chtogoto, dir, defaultxoffset, defaultyoffset, NPCfacesplayer, blocking);
}

/***********************************************************************
 * GoToCharacter(Character*ch, CharacterDirection dir, bool NPCfacesplayer, int blocking)
 * The same as GoToCharacterEx, just with an default offset of x=35 and y=20 and the player character set as default
 * blocking: 0=non-blocking; 1=blocking; 2=semi-blocking 
 * Returns 1, if the character has reached it’s goal and 0 if the movement has been cancelled before.
 * 
 ***********************************************************************/
static int Verbs::GoToCharacter(Character*ch, CharacterDirection dir, bool NPCfacesplayer, int blocking) 
{
  // same as above but with default x and y offset.
  int defaultxoffset = 35;
  int defaultyoffset = 20;
  return Verbs.GoToCharacterEx (player, ch, dir, defaultxoffset, defaultyoffset, NPCfacesplayer, blocking);
}

/***********************************************************************
 * GoTo(int blocking)
 * Go to whatever the player clicked on. This function is used to intercept a walk-to event and check if the player has reached it’s goal. 
 * E.g. this is used in the exit extension processing. blocking: 0=non-blocking; 1=blocking; 2=semi-blocking
 * 
 ***********************************************************************/
static int Verbs::GoTo(int blocking) 
{
  int xtogo, ytogo;
  int locationtype = GetLocationType(mouse.x, mouse.y);
  Hotspot* hot_spot = Hotspot.GetAtScreenXY(mouse.x, mouse.y);
  int arrived=0;
  
  if (locationtype==eLocationCharacter) {
    arrived = Verbs.GoToCharacter(Character.GetAtScreenXY(mouse.x, mouse.y), 0, false, blocking);
  }
  else {
    if (locationtype==eLocationHotspot && hot_spot.ID>0 && (hot_spot.WalkToX >0 || hot_spot.WalkToY > 0) ) {
      xtogo=hot_spot.WalkToX;
      ytogo=hot_spot.WalkToY;
    }
    else if (locationtype==eLocationObject) {
      Object*obj=Object.GetAtScreenXY(mouse.x, mouse.y);
      if (obj.Graphic > 0) xtogo=obj.X + (Game.SpriteWidth[obj.Graphic] / 2);
      else xtogo = obj.X;
      ytogo=obj.Y;
    }
    else {
      xtogo=mouse.x;
      ytogo=mouse.y;
    }
    xtogo+=GetViewportX ();
    ytogo+=GetViewportY ();
    if (blocking==0) player.Walk(xtogo, ytogo, eNoBlock);
   
    else if (blocking==1) {
      player.Walk(xtogo, ytogo, eBlock);
      arrived=1;
    }
    else if (blocking==2) arrived=Verbs.MovePlayer(xtogo, ytogo);
  }
  return arrived;
}

/***********************************************************************
 * SetApproachingChar(bool enable)
 * If set to true, the player walks to other chars before talking or giving items. 
 * This behaviour is initially defined in the guiscript, this function is used to change it during runtime.
 * 
 ***********************************************************************/
static void Verbs::SetApproachingChar(bool enable)
{
  // If set to true, the player walks to other chars before talking or giving items.
  approachCharInteract = enable;
}

/***********************************************************************
 * WalkOffScreen()
 * Handles the action of hotspots with exit extension ('>e').
 * double click on hotspots/objects will make the player exit the room instantly
 * 
 ***********************************************************************/
static void Verbs::WalkOffScreen()
{
  
  // doubleclick
  if (Verbs.UsedAction(eGA_WalkTo)) {
    if (dc_timer_run == true && exitExtensionDoubleclick) 
    {
      dc_timer_run=false;
      dc_timer_click = 0;
      
      if (location_type == eLocationHotspot) hotspot[location_id].RunInteraction(eModeUsermode1);
      else if (location_type == eLocationObject) object[location_id].RunInteraction(eModeUsermode1);
      
    }
    else
    {
      if (!disableDoubleclick && exitExtensionDoubleclick) dc_timer_run = true;
      if (Verbs.GoTo(2) ){
        int x = player.x, 
            y = player.y;
            
        int offset = walkOffScreenOffset;
        int dir = Verbs.ExtensionEx(2,location_clicked);
        
        if      (dir=='u') y -= offset;
        else if (dir=='d') y += offset;
        else if (dir=='l') x -= offset;
        else if (dir=='r') x += offset;
     
        
        if (Verbs.MovePlayerEx(x, y, eAnywhere) >0){
          if (location_type == eLocationHotspot) hotspot[location_id].RunInteraction(eModeUsermode1);
          else if (location_type == eLocationObject) object[location_id].RunInteraction(eModeUsermode1);        
        }
        
      }    
    } 
  }
}

// ============================= Unhandled Events ===========================================


/***********************************************************************
 * Unhandled(int door_script)
 *  Please check this section and replace the boring default values with your own.
 *  If you courious, how it all works, keep on reading this comment  ;-)
 * 
 * Check modes with: if(UsedAction(A_???)), check types by if(type==#). types:
 *  1   a hotspot
 *  2   a character
 *  3   an object
 *  4   an inventory item.
 *  5   inv. item on hotspot
 *  6   inv. item on character
 *  7   inv. item on object
 *  8   inv. item on inv. item
 * 
 *  You have the string "locationname" that is the name of
 *  what you clicked on, and the string "usedinvname" that is
 *  the name of the item that was used on where you clicked (only for types 5,6,7,8) 
 *
 ***********************************************************************/
static void Verbs::Unhandled(int door_script) 
{
  InventoryItem*ii = InventoryItem.GetAtScreenXY(mouse.x, mouse.y);
  int type=0;
  if (location_type == eLocationHotspot)   type = 1;
  if (location_type == eLocationCharacter) type = 2;
  if (location_type == eLocationObject)    type = 3;
  
  String locationname;
  String usedinvname;
  
  location = location_clicked;
  Verbs.RemoveExtension();
  locationname=location;
  
  if (ii!=null) type = 4;
  
  if (AGSCursorMode == eModeUseinv) {
    if (ii!=null) {
      usedinvname = ii.Name;
      location = usedinvname;
      Verbs.RemoveExtension();
      usedinvname = location;
      if (type>0) type+=4;
    }
  }
  if (AGSCursorMode != eModeUsermode2 && type != 0) {
    if (type==2 || type==6) player.FaceCharacter(character[location_id], eBlock);

    // unhandled USE
    if (Verbs.UsedAction(eGA_Use)) {
      // use inv on inv
      if (type >= 5) player.Say("That won't do any good.");
      // use
      else player.Say("I can't use that.");
    }
    
    // unhandled LOOK AT  
    else if (Verbs.UsedAction(eGA_LookAt)) {
      // look at hotspots, objects etc.
      if (type!=2) player.Say ("Nice %s", locationname);
      // look at characters
      else player.Say("It's %s",locationname); 
    }
    
    // unhandled PUSH
    else if (Verbs.UsedAction(eGA_Push)) {
      // push everything except characters
      if (type!=2) player.Say("I can't push that.");
      // push characters
      else player.Say("I can't push %s",locationname);
    }
    
    // unhandled PULL
    else if (Verbs.UsedAction(eGA_Pull)){
      // pull everything except characters
      if (type!=2) player.Say("I can't pull that.");
      // pull characters
      else player.Say("I can't pull %s",locationname);
    }
    
    // unhandled CLOSE
    else if (Verbs.UsedAction(eGA_Close)){
      if (door_script == 1) player.Say("It has already been closed.");
      else if (type == 2) player.Say("Doing that with %s is not a good idea.",locationname);
      else player.Say("I can't close that.");
    }
    
    // unhandled OPEN
    else if (Verbs.UsedAction(eGA_Open)) {
      if (door_script == 1) player.Say("It is already open.");
      else if (type ==2) player.Say("%s would not like it.",locationname);
      else player.Say("I can't open that.");
    }
    
    // unhandled PICKUP
    else if (Verbs.UsedAction(eGA_PickUp)) {
      if (type!=2) player.Say("I don't need that.");
      else player.Say("I don't want to pick %s up.",locationname);
    }

    // unhandled TALK TO
    else if (Verbs.UsedAction(eGA_TalkTo)) {
      if (type==2) player.Say("I don't want to talk to %s", locationname);
      else player.Say("I have nothing to say.");
    }
    
    // unhandled USE INV
    else if (Verbs.UsedAction(eGA_UseInv)) player.Say("That won't do any good.");
    
    // unhandled GIVE
    else if (ItemGiven != null) player.Say("I'd rather keep it.");   
    
    // unhandled DEFAULT
    else if (type==4) player.Say("I can't do that.");

  }
}

// ============================= interaction functions ===========================================

/***********************************************************************
 * EnterRoom(this Character*, int newRoom, int x, int y, CharacterDirection dir)
 * Similar to the AGS function Character.ChangeRoom. The difference is, that you can also define, 
 * it which direction the character should look. Using this function makes the character turn to the direction, mentioned above.
 * 
 ***********************************************************************/
void EnterRoom(this Character*, int newRoom, int x, int y, CharacterDirection dir) 
{
  this.ChangeRoom(newRoom, x, y);
  this.FaceDirection(dir);
}

/***********************************************************************
 * AnyClickMove(int x, int y, CharacterDirection dir) 
 * Moves the player character to the coordinates given in the parameters. 
 * If the player reaches the destination, it’s turns to the given direction. 
 * You can use this kind of functions (including the movePlayer function which is called by this function), 
 * to check if the player actually reached it’s destination.
 * Returns 1, if the character has reached it’s goal and 0 if the movement has been cancelled before. 
 * 
 ***********************************************************************/
static int Verbs::AnyClickMove(int x, int y, CharacterDirection dir) 
{
  int result = Verbs.MovePlayer(x, y);
  if (result) {
   player.FaceDirection(dir, eBlock);
  }
  return result;
}

/***********************************************************************
 * AnyClickWalk(int x, int y, CharacterDirection dir)
 * This function is almost similar to any_click_move. But it’s only called, if the current action is eMA_WalkTo. 
 * 
 ***********************************************************************/
static int Verbs::AnyClickWalk(int x, int y, CharacterDirection dir)
{
  int result=1;
  if (Verbs.UsedAction(eGA_WalkTo)) Verbs.AnyClickMove(x, y, dir);
  else result=0;
  return result;
}

/***********************************************************************
 * AnyClickWalkLook(int x, int y, CharacterDirection dir, String lookat)
 * This function moves the player character to the given location, turns it to the given direction and lets it say the message, given in the string.
 * 
 ***********************************************************************/
static int Verbs::AnyClickWalkLook(int x, int y, CharacterDirection dir, String lookat)
{
  int result=Verbs.AnyClickWalk(x, y, dir);
  if (result==0 && lookat.Length>0) {
    result=1;
    if (Verbs.AnyClickMove(x, y, dir)) {
      player.Say(lookat);
    }
  }
  return result;
}

/***********************************************************************
 * AnyClickUseInv(InventoryItem*iitem, int x, int y, CharacterDirection dir) 
 * This function moves the player to the given destination. 
 * It returns 0, if the action is unhandled, 1 is returned, if the action is handled, but has been cancelled. 
 * 2 is returned, if everything went fine.
 *
 ***********************************************************************/
static int Verbs::AnyClickUseInv(InventoryItem*iitem, int x, int y, CharacterDirection dir) 
{
  int result=0;
  if (Verbs.UsedAction(eGA_UseInv)) {
    if (player.ActiveInventory == iitem) {
      if (Verbs.AnyClickMove(x, y, dir)) result = 2;
      else result = 1;
    }
  }
  return result;

}

/***********************************************************************
 * AnyClickUseInv(InventoryItem*iitem, int x, int y, CharacterDirection dir) 
 * This function starts the same as any_click_walk_look. If an object ID > 0 has been given, this object is set invisible. 
 * Afterwards the inventory item is going to be added to the player’s inventory and if there’s an audioclip in the parameters, that one is played too. 
 * It returns 0, if the action is unhandled, 1 is returned, if the action is handled, but has been cancelled. 
 * 2 is returned, if the item was picked up
 *
 ***********************************************************************/
static int Verbs::AnyClickWalkLookPick(int x, int y, CharacterDirection dir, String lookat, int obj, InventoryItem*iitem, AudioClip *sound) 
{
  AudioChannel *chan;
  int result=Verbs.MovePlayer(x, y);
  
  if (result>0 && Verbs.UsedAction(eGA_PickUp)) {
    if (Verbs.AnyClickMove(x, y, dir)) {
      if (lookat.Length>0) player.Say(lookat);
      if (sound != null)chan = sound.Play();
      if (obj>=0) object[obj].Visible=false;
      if (iitem!=null) player.AddInventory(iitem);
      result=2;
    }
  }
  return result;
}

// ============================= Door functions ==========================================

/***********************************************************************
 * AnyClickSpecial(int door_id, int obj, int x, int y, CharacterDirection dir, int nr_room, int nr_x, int nr_y, CharacterDirection nr_dir, AudioClip *opensound, AudioClip *closesound, int key, int closevalue)
 * This function extends AnyClick with the following parameters:
 * 
 *   opensound: custom sound to be played, when the door is being opend 
 *   closesound: custom sound to be played, when the door is being closed 
 *   key: the id of the inventory item, that can unlock the door, -1 masterkey, -2 if the door cannot be unlocked 
 *   closevalue: default 0 (closed), but you can also set 2 (locked). 
 ***********************************************************************/
static int Doors::AnyClickSpecial(int door_id, int obj, int x, int y, CharacterDirection dir, int nr_room, int nr_x, int nr_y, CharacterDirection nr_dir, AudioClip *opensound, AudioClip *closesound, int key, int closevalue) {
  // key = -1: masterkey - even locked doors will be opened
  // key = -2: door can't be unlocked (like rusted) 
  AudioChannel *chan;
  int result=1;
  
  if (Verbs.UsedAction(eGA_Close)) {
    if (Doors.GetDoorState(door_id) == 0 || Doors.GetDoorState(door_id) == 2) Verbs.Unhandled(1);
    else if (Doors.GetDoorState(door_id) == 1 ) {
      if (Verbs.AnyClickMove(x, y, dir)) {
        if (closesound != null) chan = closesound.Play();
        // Play default sound
        else if (closeDoorSound != null) chan = closeDoorSound.Play();
        object[obj].Visible=false;
        Doors.SetDoorState(door_id, closevalue);
      }
    }
  }
  else if (Verbs.UsedAction(eGA_Open)) {
    if (Doors.GetDoorState(door_id) == 0 || (Doors.GetDoorState(door_id) == 2 && key == -1 ) ) {
      if (Verbs.AnyClickMove (x, y, dir))
      {
        if (opensound != null) chan = opensound.Play();
        // Play default sound
        else if (openDoorSound != null) chan = openDoorSound.Play();     
        
        object[obj].Visible=true;
        Doors.SetDoorState(door_id, 1);
      }
    }
    else if (Doors.GetDoorState(door_id) == 1 ) Verbs.Unhandled(1);
    else if (Doors.GetDoorState(door_id) == 2 ) {
      if (Verbs.AnyClickMove(x, y, dir)) if (!String.IsNullOrEmpty(Doors.GetDoorStrings("islocked"))) player.Say(Doors.GetDoorStrings("islocked"));
    }
  }
  else if (Verbs.UsedAction(eGA_WalkTo)) 
  {
    if (Doors.GetDoorState(door_id) == 1) {
      if (dc_timer_run == true && exitDoorDoubleclick == true) 
      {
        dc_timer_run = false;
        dc_timer_click = 0;
        if (Verbs.MovePlayerEx(player.x, player.y, eWalkableAreas) > 0 ) player.EnterRoom(nr_room, nr_x, nr_y, nr_dir);
        result = 2;
      }
      else 
      {
        if (exitDoorDoubleclick && !disableDoubleclick) dc_timer_run = true;

        if (Verbs.GoTo(2)){
          player.EnterRoom(nr_room, nr_x, nr_y, nr_dir);
          result = 2;          
        }
        
      }
    }
    else Verbs.AnyClickMove(x, y, dir);

  }
  else if (Verbs.UsedAction (eGA_LookAt) && !String.IsNullOrEmpty(Doors.GetDoorStrings("lookat")) ) {
    if (Verbs.AnyClickMove (x, y, dir)) if (!String.IsNullOrEmpty(Doors.GetDoorStrings("lookat")))player.Say(Doors.GetDoorStrings("lookat"));
  }
  else if (Verbs.UsedAction(eGA_UseInv) && key >= 0) {
    if (Verbs.AnyClickMove(x, y, dir)) {
      if (player.ActiveInventory == inventory[key] ) {
        if (Doors.GetDoorState(door_id) == 1 ) { 
          if (!String.IsNullOrEmpty(Doors.GetDoorStrings("closefirst")) ) player.Say(Doors.GetDoorStrings("closefirst"));
        }
        else if (Doors.GetDoorState(door_id) == 2 ) {
          if (unlockDoorSound != null) chan = unlockDoorSound.Play();
          if (!String.IsNullOrEmpty(Doors.GetDoorStrings("unlock"))) player.Say(Doors.GetDoorStrings("unlock"));
          Doors.SetDoorState(door_id, closevalue);
        } 
        else if (Doors.GetDoorState(door_id) == 0 ) {
          object[obj].Visible=false;
          Doors.SetDoorState(door_id, 2);
          if (!String.IsNullOrEmpty(Doors.GetDoorStrings("relock"))) player.Say(Doors.GetDoorStrings("relock"));
        }
      }
      else if (!String.IsNullOrEmpty(Doors.GetDoorStrings("wrongitem"))) player.Say(Doors.GetDoorStrings("wrongitem"));
    }
  }
  else result=0;
  
  return result;
  // 0 = unhandled
  // 1 = handled
  // 2 = NewRoom
}

/***********************************************************************
 * AnyClick(int door_id, int obj, int x, int y, CharacterDirection dir, int nr_room, int nr_x, int nr_y, CharacterDirection nr_dir)
 * This function is used in the room script in combination with the door hotspot. Parameters:
 * 
 *   door_id: The door id, you have defined 
 *   act_object: The object, containing the open sprite 
 *   x,y: the walk-to point of the door (please don’t use the built in "walk-to coordinates" feature of the room editor. 
 *   dir: the direction, the player’s character should face, after it reached x,y 
 *   nr_room: if the door is opened and walking through it, the player is being send to this room 
 *   nr_x,nr_y: the x,y coordinates of inside of the new room 
 *   nr_dir: after the room change, the player faces this direction 
 *   This is the main function of the door scripts. With this you connect the hotspot with the door and the player’s action. 
 *
 * If you have defined default door sounds, these are also being called in this function. 
 * Also you can’t unlock a door with this function. You need AnyClickSpecial for that.
 ***********************************************************************/
static int Doors::AnyClick(int door_id, int obj, int x, int y, CharacterDirection dir, int nr_room, int nr_x, int nr_y, CharacterDirection nr_dir) {
  return Doors.AnyClickSpecial (door_id, obj, x, y, dir, nr_room, nr_x, nr_y, nr_dir, null, null, 0, 0);
}


// ============================= AGS internal functions ==========================================

/***********************************************************************
 * game_start()
 * 
 ***********************************************************************/
function game_start()
{
  
  String tr_lang;
  // --- translate GUI action buttons ---
  tr_lang = GetTranslation("GUI_LANGUAGE");
  tr_lang = tr_lang.LowerCase();
  
  if (tr_lang == "de") {
    lang = eLangDE;
  }
  else if (tr_lang =="es") {
    lang = eLangES;
  }
  else if (tr_lang =="fr") {
    lang = eLangFR;
  }  
  else if (tr_lang =="en") {
    lang = eLangEN;
  }
  else if (tr_lang =="it") {
    lang = eLangIT;
  }     
  Verbs.InitGuiLanguage();
  Verbs.AdjustGUIText();
  
  Verbs.AdjustActionBarPosition();
  // --- initialize game settings ---
  Verbs.SetDefaultAction(eGA_WalkTo);    
  Verbs.SetDoubleClickSpeed(GetGameSpeed()/4);
  Verbs.HandleInvArrows();
  
  Doors.SetDoorStrings("The door looks solid.","It is locked.","I can't unlock it with that.","I have to close it first.","Now it's unlocked.","The door is locked again.");
  
  player_ani_speed =  player.AnimationSpeed;
  player_walk_x_speed = player.WalkSpeedX;
  player_walk_y_speed = player.WalkSpeedY;
  if (runSpeedupRate <=0 ) runSpeedupRate = 1;
  
}

/***********************************************************************
 * on_event(EventType event, int data)
 * 
 ***********************************************************************/
function on_event(EventType event, int data)
{
  if (event == eEventEnterRoomBeforeFadein) {
    Verbs.CheckDefaultAction();
    Verbs.UpdateActionBar();
  }
}

/***********************************************************************
 * on_key_press(eKeyCode keycode)
 * 
 ***********************************************************************/
function on_key_press(eKeyCode keycode) 
{
  
  // Show pause gui on space-key
  if (keycode == eKeySpace)
  {
    if (!IsGamePaused()) {
      PauseGame();
      Verbs.AdjustGUIText();
      gPause.Visible=true;
    }
    else {
      gPause.Visible=false;
      UnPauseGame();
      Verbs.SetAction(eGA_Default);
      lblAction.TextColor=actionLabelColorHighlighted;      
      Verbs.CheckDefaultAction();
      Verbs.UpdateActionBar();
    }
  }

  if (gQuit.Visible) {
    if (keycode==key_u_no || keycode==key_l_no) gQuit.Visible=false; 
    if (keycode==key_u_yes || keycode==key_l_yes) QuitGame(0);
  }
  
  //  triggering actions by keyboard
  if (!IsGamePaused()) {
    int act_i=0;
    while (act_i < ACT_COUNT) {
      if (keycode == action_l_keycode[act_i] || keycode==action_u_keycode[act_i]) {
        Verbs.SetAction(act_i);
        act_i = ACT_COUNT;
      }
      else {
        act_i++;
      }
    }
  } 
}

/***********************************************************************
 * on_mouse_click(MouseButton button)
 * 
 ***********************************************************************/
function on_mouse_click(MouseButton button) {
  
  if (!Verbs.IsGuiDisabled()) {
    int x = mouse.x;
    int y = mouse.y;
    
    // get location under mouse cursor
    location_type = GetLocationType(x, y);
    location_clicked = Game.GetLocationName(x, y);

    AGSCursorMode = Mouse.Mode;
    used_action = global_action;
    
    InventoryItem*ii = InventoryItem.GetAtScreenXY(x, y);
    if (location_type == eLocationHotspot) {
      Hotspot*h = Hotspot.GetAtScreenXY(x, y);
      location_id=h.ID;
      
    }
    else if (location_type == eLocationCharacter) {
      Character*c=Character.GetAtScreenXY(x, y);
      location_id=c.ID;
    }
    else if (location_type==eLocationObject) {
      Object*o=Object.GetAtScreenXY(x, y);
      location_id=o.ID;
    }
    else if (ii!=null) location_id=ii.ID;
    
    //dont allow endless running
    if (player_is_running) {
      player_is_running = false;
      dc_timer_run = false;
      dc_timer_click = 0;
      
      player.StopMoving();
      player.SetWalkSpeed(player_walk_x_speed,  player_walk_y_speed);
      player.AnimationSpeed = player_ani_speed;          
    }
    
    
    if (IsGamePaused()) {
      // Game is paused, so do nothing (ie. don't allow mouse click)
    }
    // Mousebutton Left
    else if (button == eMouseLeft) 
    {

      if (Verbs.GlobalCondition(eGlob_InvOnInv) || Verbs.GlobalCondition(eGlob_GiveTalkNoChar) || Verbs.GlobalCondition(eGlob_GiveNoInv)) {
        // Do nothing, if:
        // the mode is useinv and the mouse is over the active inv (like "use knife on knife")
        // or the mode is talk, or "Give", and the mouse isnt over a character
        // or its GIVE and the mouse isnt over a inv.item        
        if (classicGui) {
        }
        // the modern GUI Style turns TalkTo and Give into the Default mode.
        else {
          if (AGSCursorMode==eModeTalkto || AGSCursorMode == eModeInteract ) {
            Verbs.UpdateActionBar();
            lblAction.TextColor = actionLabelColorHighlighted;
            Verbs.SetAction(eGA_Default);
            ItemGiven=null;            
          }
          else {
          }
        }
      }
      else if (Verbs.ExtensionEx(1, location_clicked)=='e') {
        Verbs.UpdateActionBar();
        lblAction.TextColor = actionLabelColorHighlighted;
        Verbs.WalkOffScreen();
      }
      // walk to
      else if (AGSCursorMode == eModeUsermode2) {
        lblAction.TextColor=actionLabelColorHighlighted;

        // Run on doubleclick
        if (dc_timer_run == true && runOnDoubleClick) {
          
          if (location_type == eLocationNothing) {
            player_is_running = true;
            dc_timer_run = false;
            dc_timer_click = 0;
          
            if (player_ani_speed < runSpeedupRate) player.AnimationSpeed  = 0;
            else player.AnimationSpeed = player_ani_speed / runSpeedupRate;
            player.StopMoving();
            
            player.SetWalkSpeed(player_walk_x_speed * runSpeedupRate, player_walk_y_speed * runSpeedupRate);
          }
        }

        if (IsInteractionAvailable(x, y, AGSCursorMode) ) {
          Room.ProcessClick (x, y, AGSCursorMode);
        }
        else {
          Room.ProcessClick (x, y, eModeWalkto);
        }
        
        if (!disableDoubleclick && runOnDoubleClick && location_type == eLocationNothing){
          dc_timer_run = true;
        }

      }   
      // talkto
      else if (AGSCursorMode==eModeTalkto && IsInteractionAvailable(x, y, AGSCursorMode) && location_type==eLocationCharacter) {
        lblAction.TextColor=actionLabelColorHighlighted;
        Verbs.SetAction(eGA_Default);
        if (approachCharInteract == false) character[location_id].RunInteraction(AGSCursorMode); 
        else {
          if (Verbs.GoToCharacter(character[location_id], 0, NPCfacingPlayer, 2)) character[location_id].RunInteraction(AGSCursorMode);
        }
            
      }
      // Giveto
      else if ((AGSCursorMode == eModeUseinv) && location_type==eLocationCharacter && Verbs.IsAction(eGA_GiveTo)) {
        lblAction.TextColor = actionLabelColorHighlighted;
        ItemGiven=player.ActiveInventory;
        Verbs.SetAction (eGA_Default);
        if (approachCharInteract == false) {
          if (IsInteractionAvailable (x, y, eModeUseinv) == 1) {
            character[location_id].RunInteraction(eModeUseinv);
          }
        }
        else {
          if (Verbs.GoToCharacter(character[location_id], 0, NPCfacingPlayer, 2)) {
            if (IsInteractionAvailable (x, y, eModeUseinv) == 1) {
              character[location_id].RunInteraction(eModeUseinv);        
            }
          }
        }
        
      }     
      else {
        Verbs.UpdateActionBar();
        lblAction.TextColor = actionLabelColorHighlighted;
        Room.ProcessClick(x, y, AGSCursorMode);
        Verbs.SetAction(eGA_Default);
        ItemGiven=null;
      }
    }
    // Mousebutton Right
    else if (button==eMouseRight) {
      if (alternative_action==eGA_Default) {
        Verbs.SetAction(eGA_Default);
        lblAction.TextColor=actionLabelColorHighlighted;
        
        if (Mouse.Mode==eModeUsermode2) {
          if (Verbs.ExtensionEx(1, location_clicked)=='e') {
            Verbs.UpdateActionBar();
            lblAction.TextColor=actionLabelColorHighlighted;
            Verbs.WalkOffScreen();
          }          
          else {
            Room.ProcessClick(x, y, eModeWalkto);
          }
        }
        else {
          Room.ProcessClick(x, y, Mouse.Mode);

        }
      }
      else {
        Verbs.SetAction(alternative_action);
        used_action=global_action;
        Verbs.UpdateActionBar();
        lblAction.TextColor=actionLabelColorHighlighted;
        AGSCursorMode=Mouse.Mode;
        if (AGSCursorMode == eModeTalkto && IsInteractionAvailable(x, y, AGSCursorMode) && location_type == eLocationCharacter) {
          if (approachCharInteract == false) {
            character[location_id].RunInteraction(AGSCursorMode);
          }
          else {
            if (Verbs.GoToCharacter(character[location_id], 0, NPCfacingPlayer,2 )) character[location_id].RunInteraction(AGSCursorMode);   
          }
        }
        else {

          Room.ProcessClick(x, y, AGSCursorMode);
        }
        Verbs.SetAction(eGA_Default);
      }
      
    }
    //left click in inventory
    else if (button==eMouseLeftInv) {
      if (!Verbs.IsAction(eGA_GiveTo))ItemGiven= null;
   
      if (Verbs.GlobalCondition (eGlob_MouseInvWalk)) {
        // if the mouse is in the inventory and modes Walk is selected
        Verbs.SetAction (eGA_Use);
        location = inv_ex_location;    
        if (Verbs.Extension()=='u' && ii.IsInteractionAvailable(eModeInteract)) {
          // use it immediately (not with anything else)
          used_action = global_action;
          ii.RunInteraction(eModeInteract);
          Verbs.SetAction(eGA_Default);
        }
        else {
          player.ActiveInventory=ii;
        }
      } 
      else  if (Verbs.GlobalCondition(eGlob_InvOnInv)) {
        // if the mode is useinv and the mouse is over the active inv (like "use knife on knife")
        // so do nothing again
      }
      else {
        used_action = global_action;
        if (Mouse.Mode == eModeInteract && ii != null) {
          if (Verbs.IsAction(eGA_Use) && ii.IsInteractionAvailable(eModeInteract)) {
            lblAction.TextColor=actionLabelColorHighlighted;
            ii.RunInteraction(eModeInteract);
            Verbs.SetAction(eGA_Default);
          }
          else player.ActiveInventory=ii;
        }
        else {
          if ( (Mouse.Mode >0 && Mouse.Mode <10 )&& ii != null) {
            AGSCursorMode=Mouse.Mode;
            lblAction.TextColor = actionLabelColorHighlighted;
            ii.RunInteraction(Mouse.Mode);
            Verbs.SetAction(eGA_Default);
          }
        }
      }
    }
    //right click in inventory
    else if (button==eMouseRightInv) {
      if (alternative_action==eGA_Default) {
        Verbs.SetAction(eGA_Default);
      }
      else {
        Verbs.SetAction(alternative_action);
        used_action=global_action;
        AGSCursorMode=Mouse.Mode;
        if (Mouse.Mode==eModeInteract && ii != null) {
          if (Verbs.IsAction(eGA_Use) && ii.IsInteractionAvailable(eModeInteract)) {
            Verbs.UpdateActionBar();
            lblAction.TextColor = actionLabelColorHighlighted;
            ii.RunInteraction(eModeInteract);
            Verbs.SetAction(eGA_Default);
          }
          else player.ActiveInventory=ii;
        }
        else {
          Verbs.UpdateActionBar();
          lblAction.TextColor = actionLabelColorHighlighted;
          inventory[game.inv_activated].RunInteraction(Mouse.Mode);
          Verbs.SetAction(eGA_Default);
        }
      }
    }
  }
  else {
    Room.ProcessClick(mouse.x, mouse.y, Mouse.Mode);
  }
}

/***********************************************************************
 * repeatedly_execute()
 * 
 ***********************************************************************/
function repeatedly_execute() {

  if (!IsGamePaused() && !Verbs.IsGuiDisabled())
  {
    
    if (classicGui == true) {
      Verbs.CheckDefaultAction();
      Verbs.UpdateActionBar(); 
    }
    Verbs.HandleInvArrows();
  
  
    // Keep running, if mouse is pressed
    if (player_is_running && mouse.IsButtonDown(eMouseLeft)) {

      int mx = mouse.x + GetViewportX();
      int my = mouse.y + GetViewportY();
      int px = player.x;
      int py = player.y;
      int dist  = FloatToInt(Verbs.Distance(mx, my, px, py), eRoundDown);
      
      if (!player.Moving) {
        // Running on an exit or door
        if (dist <= runCursorDistance && (Verbs.ExtensionEx(1, location_ex)=='e' || Verbs.ExtensionEx(1, location_ex)=='v')) {
          player_is_running = false;
          player.StopMoving();
          player.SetWalkSpeed(player_walk_x_speed,  player_walk_y_speed);
          player.AnimationSpeed = player_ani_speed;          
          Verbs.UpdateActionBar();
          lblAction.TextColor = actionLabelColorHighlighted;
          Room.ProcessClick(mouse.x, mouse.y, eModeUsermode1);      
        }
        // else keep running while left mouse button pressed
        else if (dist > runCursorDistance ) {
          player.Walk(mx, my, eNoBlock);
        }
      }
    }
    // turn off running if player stops walking
    else if (player_is_running && !player.Moving && !mouse.IsButtonDown(eMouseLeft)) {
      player_is_running = false;
      dc_timer_run = false;
      dc_timer_click = 0;
      
      player.StopMoving();
      player.SetWalkSpeed(player_walk_x_speed,  player_walk_y_speed);
      player.AnimationSpeed = player_ani_speed;          
    }
  }
}

/***********************************************************************
 * repeatedly_execute_always()
 * 
 ***********************************************************************/
function repeatedly_execute_always() {
  
  
  if (!IsGamePaused() && !Verbs.IsGuiDisabled()) {
  
    // Update Actionbar
    if (classicGui == false) {
      Verbs.CheckDefaultAction();

      // Update Actionbar after command is executed
      if (location_clicked != null && location_clicked.Length > 0) {
        if (location_clicked.IndexOf(">") > 0) temp_location = location_clicked.Truncate(location_clicked.IndexOf(">"));
        else temp_location = location_clicked;
      }
      else temp_location = "";

      if (IsInterfaceEnabled() || temp_location != location || location == "") {
        Verbs.UpdateActionBar();
        location_clicked = "";
      }
      Verbs.AdjustActionBarPosition();
    }
    // Doubleclick Timer
    if (dc_timer_run == true)
    {
      if (disableDoubleclick) {
        dc_timer_run = false;
      }
      else {
        dc_timer_click++;
        if (dc_timer_click >= dc_speed){
          dc_timer_click = 0;
          dc_timer_run = false;
        }
      }
    }
  }
}

export ItemGiven;